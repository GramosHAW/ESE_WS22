/*
 * ExternDispatcher.cpp
 *
 *  Created on: 25 Nov 2022
 *      Author: Sami Askar
 */

#include "ExternDispatcher.h"

ExternDispatcher::ExternDispatcher() {
	this->tExtern = nullptr;
	this->run_thread = true;
	// TODO Auto-generated constructor stub

}

ExternDispatcher::~ExternDispatcher() {
	// TODO Auto-generated destructor stub
}

void ExternDispatcher::client(std::promise<int> && p) {
	system("slay gns");
	system("gns -c");
	int server_coid;
	header_t header;
	app_header_t app_header;
	iov_t iov[3]; // multi part msg
	char r_msg[512]; // buffer for the answer
	char const *payload0 = "Hallo Welt!";
	if ((server_coid = name_open(ATTACH_POINT, NAME_FLAG_ATTACH_GLOBAL))
			== -1) {
		p.set_value(NO_SERVER);
		return;
	}
	printf("Connected to server! \n");
	p.set_value(CONNECTION_OK); //TODO: Define Variable CONNECTION_OK
	printf("Client preparing message to send.. \n");
	int payload_size = strlen(payload0) + 1; // +1 due to string end (\0)
	header.type = STR_MSG; // define msg type
	header.subtype = 0x00;
	app_header.size = payload_size; // fill application header
	app_header.count = 0;
	SETIOV(iov + 0, &header, sizeof(header));
	SETIOV(iov + 1, &app_header, sizeof(app_header));
	SETIOV(iov + 2, payload0, payload_size);
	printf("Client sending msg..\n");
	// send msg
	if (-1 == MsgSendvs(server_coid, iov, 3, r_msg, sizeof(r_msg))) {
		perror("Client: MsgSend failed");
		exit(EXIT_FAILURE);
	}
	printf("Client: Answer from server: %s \n", r_msg);
	name_close(server_coid);
	return;
}
int ExternDispatcher::server() {
	system("gns -s");
	name_attach_t *attach;
	// Create a unique global name known within the network
	if ((attach = name_attach(NULL, ATTACH_POINT, NAME_FLAG_ATTACH_GLOBAL)) == NULL) {
		perror("Server: name_attach failed");
		return EXIT_FAILURE;
	}
	printf("Server: Channel created!..\n");
	while (1) {
		// Waiting for a message and read first header
		header_t header;
		int rcvid = MsgReceive(attach->chid, &header, sizeof(header_t), NULL);
		if (rcvid == -1) { // Error occurred
			perror("Server: MsgReceived failed");
			break;
		}
		if (rcvid == 0) { // Pulse was received
			handle_pulse(header, rcvid);
			continue;
		}
		// continue while (1) loop
		// some sync msg was received
		if ((_IO_BASE <= header.type) && (header.type <= _IO_MAX)) {
			// Some QNX IO msg generated by gns was received
			handle_ONX_IO_msg(header, rcvid);
			continue;
		}
		// A sync msg (presumable ours) was received; handle it
		handle_app_msg(header, rcvid);
	}
	name_detach(attach, 0);
	return 0;
}
void ExternDispatcher::handle_pulse(header_t hdr, int rcvid) {
	switch (hdr.code) {
	case _PULSE_CODE_DISCONNECT:
		printf("Server received _PULSE_CODE_DISCONNECT\n");
		/* A client disconnected all its connections (called
		 * name_close() for each name_open() of our name) or
		 * terminated. */
		ConnectDetach(hdr.scoid);
		break;
	case _PULSE_CODE_UNBLOCK:
		printf("Server received _PULSE_CODE_UNBLOCK\n");
		/* REPLY blocked client wants to unblock (was hit by
		 * a signal or timed out). It's up to you if you
		 * reply now or later. */
		break;
	default:
		/* A pulse sent by one of your processes or a
		 * _PULSE_CODE_COIDDEATH or _PULSE_CODE_THREADDEATH
		 * from the kernel? */
		printf("Server received some pulse msg.\n");
		break;
	}
}
void ExternDispatcher::handle_ONX_IO_msg(header_t hdr, int rcvid) {
	if (hdr.type == _IO_CONNECT) {
// QNX IO msg _IO_CONNECT was received; answer with EOK
		printf("Server received _IO_CONNECT (sync. msg) \n");
		MsgReply(rcvid, EOK, NULL, 0);
		return;
	}
// Some other QNX IO message was received; reject it
	printf("Server received unexpected (sync.) msg type = 0x%04X\n", hdr.type);
	MsgError(rcvid, ENOSYS);
}

void ExternDispatcher::handle_app_msg(header_t hdr, int rcvid) {
	const char *ret_msg = "Got the message";
	if (DATA_MSG == hdr.type) {
		printf("Server: DATA_MSG not supported.\n");
		MsgError(rcvid, EPERM);
	} else if (STR_MSG == hdr.type) {
		printf("Server: STR_MSG received.\n");
// read app header
		app_header_t app_header;
		MsgRead(rcvid, &app_header, sizeof(app_header), sizeof(header_t));
// ToDo Check return value of MsgRead, in particular number of read bytes
// read payload
		char * buf = (char*) malloc(app_header.size);// ToDo check return value of malloc
		MsgRead(rcvid, buf, app_header.size,
				sizeof(header_t) + sizeof(app_header_t));
// ToDo Check return value of MsgRead, in particular number of read bytes
		printf("Server: got STR_MSG (count = %d): %s \n", app_header.count,
				buf);
		MsgReply(rcvid, EOK, ret_msg, strlen(ret_msg) + 1);		// send reply
		free(buf);
	} else { // Wrong msg type
		printf("Server: Wrong message type 0x%04X\n", hdr.type);
		MsgError(rcvid, EPERM);
	}
}

int ExternDispatcher::startThread(void) {
	printf("Hello from start thread..\n");
	std::promise<int> retClient;
	auto futureClient = retClient.get_future();
	std::thread t(&ExternDispatcher::client, this, std::move(retClient));
	t.join();
	int clientRetVal = futureClient.get();
	if (clientRetVal == NO_SERVER) {
		printf("Channel doesnt exist.. Starting server function.. \n");
		//std::promise<int> retServer;
		//auto futureServer = retServer.get_future();
		std::thread t(&ExternDispatcher::server, this);
		t.join();
		//int serverRetVal = futureServer.get();
	}
	return 0;
}
/*
 int ExternDispatcher::startThread(void) {
 std::thread t(&ExternDispatcher::server, this );
 t.join();
 return 0;
 }*/

